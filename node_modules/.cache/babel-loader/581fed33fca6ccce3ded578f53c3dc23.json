{"ast":null,"code":"'use strict';\n\nrequire(\"reactotron-core-client\");\n\nvar is = require(\"@redux-saga/is\"),\n    effects = require(\"redux-saga/effects\");\n\nfunction _classCallCheck(a, b) {\n  if (!(a instanceof b)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(a, b) {\n  for (var c, d = 0; d < b.length; d++) c = b[d], c.enumerable = c.enumerable || !1, c.configurable = !0, \"value\" in c && (c.writable = !0), Object.defineProperty(a, c.key, c);\n}\n\nfunction _createClass(a, b, c) {\n  return b && _defineProperties(a.prototype, b), c && _defineProperties(a, c), a;\n}\n\nfunction _defineProperty(a, b, c) {\n  return b in a ? Object.defineProperty(a, b, {\n    value: c,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : a[b] = c, a;\n}\n\nfunction _objectSpread(a) {\n  for (var b = 1; b < arguments.length; b++) {\n    var c = null == arguments[b] ? {} : arguments[b],\n        d = Object.keys(c);\n    \"function\" == typeof Object.getOwnPropertySymbols && (d = d.concat(Object.getOwnPropertySymbols(c).filter(function (a) {\n      return Object.getOwnPropertyDescriptor(c, a).enumerable;\n    }))), d.forEach(function (b) {\n      _defineProperty(a, b, c[b]);\n    });\n  }\n\n  return a;\n}\n\nvar TAKE = effects.effectTypes.TAKE,\n    PUT = effects.effectTypes.PUT,\n    ALL = effects.effectTypes.ALL,\n    RACE = effects.effectTypes.RACE,\n    CALL = effects.effectTypes.CALL,\n    CPS = effects.effectTypes.CPS,\n    FORK = effects.effectTypes.FORK,\n    JOIN = effects.effectTypes.JOIN,\n    CANCEL = effects.effectTypes.CANCEL,\n    SELECT = effects.effectTypes.SELECT,\n    ACTION_CHANNEL = effects.effectTypes.ACTION_CHANNEL,\n    CANCELLED = effects.effectTypes.CANCELLED,\n    FLUSH = effects.effectTypes.FLUSH,\n    GET_CONTEXT = effects.effectTypes.GET_CONTEXT,\n    SET_CONTEXT = effects.effectTypes.SET_CONTEXT,\n    PARALLEL = \"PARALLEL\",\n    ITERATOR = \"ITERATOR\",\n    PROMISE = \"PROMISE\",\n    UNKNOWN = \"UNKNOWN\",\n    PENDING = \"PENDING\",\n    RESOLVED = \"RESOLVED\",\n    REJECTED = \"REJECTED\",\n    EffectManager = function () {\n  function a() {\n    _classCallCheck(this, a), this.rootIds = [], this.map = {}, this.childIdsMap = {};\n  }\n\n  return _createClass(a, [{\n    key: \"get\",\n    value: function (a) {\n      return this.map[a];\n    }\n  }, {\n    key: \"set\",\n    value: function (a, b) {\n      this.map[a] = b, this.childIdsMap[b.parentEffectId] || (this.childIdsMap[b.parentEffectId] = []), this.childIdsMap[b.parentEffectId].push(a);\n    }\n  }, {\n    key: \"setRootEffect\",\n    value: function (a, b) {\n      this.rootIds.push(a), this.set(a, _objectSpread({}, b, {\n        root: !0\n      }));\n    }\n  }, {\n    key: \"getRootIds\",\n    value: function () {\n      return this.rootIds;\n    }\n  }, {\n    key: \"getChildIds\",\n    value: function (a) {\n      return this.childIdsMap[a] || [];\n    }\n  }]), a;\n}();\n\nfunction getEffectName(a) {\n  return is.array(a) ? PARALLEL : is.iterator(a) ? ITERATOR : is.promise(a) ? PROMISE : is.effect(a) ? a.type : UNKNOWN;\n}\n\nfunction getEffectDescription(a) {\n  if (!a) return UNKNOWN;\n  if (a.root) return a.saga.name;\n  if (is.iterator(a)) return a.name || UNKNOWN;\n  if (is.array(a)) return null;\n\n  if (is.promise(a)) {\n    var b;\n    return b = a.name ? \"\".concat(PROMISE, \"(\").concat(a.name, \")\") : a.constructor instanceof Promise.constructor ? PROMISE : \"\".concat(PROMISE, \"(\").concat(a.constructor.name, \")\"), b;\n  }\n\n  if (is.effect(a)) {\n    var c = a,\n        d = c.type,\n        e = c.payload;\n    if (d === TAKE) return e.pattern || \"channel\";\n    if (d === PUT) return e.channel ? e.action : e.action.type;\n    if (d === ALL) return null;\n    if (d === RACE) return null;\n    if (d === CALL) return e.fn.name && \"\" !== e.fn.name.trim() ? e.fn.name : \"(anonymous)\";\n    if (d === CPS) return e.fn.name;\n    if (d === FORK) return e.fn.name;\n    if (d === JOIN) return e.name;\n    if (d === CANCEL) return e.name;\n    if (d === SELECT) return e.selector.name;\n    if (d === ACTION_CHANNEL) return null == e.buffer ? e.pattern : e;\n    if (d === CANCELLED) return null;\n    if (d === FLUSH) return e;\n    if (d === GET_CONTEXT) return e;\n    if (d === SET_CONTEXT) return e;\n  }\n\n  return UNKNOWN;\n}\n\nvar isRaceEffect = function (a) {\n  return is.effect(a) && a.type === RACE;\n},\n    _createSagaMonitor = function (a) {\n  var i = Math.round;\n\n  function b(a) {\n    var b = m();\n    a.end = b, a.duration = b - a.start;\n  }\n\n  function c(a, b, d) {\n    var e = k.get(b);\n\n    if (e) {\n      var f = null;\n      if (e.name) switch (e.name) {\n        case CALL:\n          f = e.effect.payload.args;\n          break;\n\n        case PUT:\n          f = e.effect.payload.action;\n          break;\n\n        case RACE:\n          break;\n\n        default:\n          f = e.effect.payload;\n      }\n      d.push({\n        depth: a,\n        effectId: e.effectId,\n        parentEffectId: e.parentEffectId || null,\n        name: e.name || null,\n        description: e.description || null,\n        duration: i(e.duration),\n        status: e.status || null,\n        winner: e.winner || null,\n        result: e.result || null,\n        extra: f || null\n      }), k.getChildIds(b).forEach(function (b) {\n        return c(a + 1, b, d);\n      });\n    }\n  }\n\n  function d(d) {\n    var e = k.get(d);\n\n    if (b(e), !(-1 < l.indexOf(e.description))) {\n      var f,\n          g,\n          h = [],\n          j = k.get(e.parentEffectId);\n\n      if (e.name && e.name === FORK) {\n        var m = e.effect.payload.args,\n            n = 0 < m.length ? m[m.length - 1] : null;\n        g = n && n.type, j ? j.name && j.name === ITERATOR && (f = j.description) : (f = \"(root)\", g = \"\".concat(e.description, \"()\")), k.getChildIds(d).forEach(function (a) {\n          return c(0, a, h);\n        });\n      }\n\n      a.send(\"saga.task.complete\", {\n        triggerType: g || e.description,\n        description: f,\n        duration: i(e.duration),\n        children: h\n      });\n    }\n  }\n\n  function e(a, b) {\n    var c = Object.keys(b)[0];\n    k.getChildIds(a).forEach(function (a) {\n      var b = k.get(a);\n      b.label === c && (b.winner = !0);\n    });\n  }\n\n  function f(a, c) {\n    var d = k.get(a);\n    b(d), d.status = REJECTED, d.error = c, isRaceEffect(d.effect) && e(a, c);\n  }\n\n  function g(a) {\n    var c = k.get(a);\n    b(c), c.status = CANCELLED;\n  }\n\n  function h(c, i) {\n    var j = k.get(c);\n    is.task(i) ? i.toPromise().then(function (a) {\n      i.isCancelled() ? g(c) : (h(c, a), d(c));\n    }, function (b) {\n      f(c, b), b.reactotronWasHere || a.reportError(b), b.reactotronWasHere = !0;\n    }) : (b(j), j.status = RESOLVED, j.result = i, isRaceEffect(j.effect) && e(c, i));\n  }\n\n  var j = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {},\n      k = new EffectManager(),\n      l = j.except || [],\n      m = a.startTimer();\n  return {\n    rootSagaStarted: function (a) {\n      k.setRootEffect(a.effectId, _objectSpread({}, a, {\n        status: PENDING,\n        start: m()\n      }));\n    },\n    effectTriggered: function (a) {\n      k.set(a.effectId, _objectSpread({}, a, {\n        status: PENDING,\n        start: m(),\n        name: getEffectName(a.effect),\n        description: getEffectDescription(a.effect)\n      }));\n    },\n    effectResolved: h,\n    effectRejected: f,\n    effectCancelled: g,\n    actionDispatched: function () {}\n  };\n},\n    index = function (a) {\n  return function (b) {\n    return {\n      features: {\n        createSagaMonitor: function () {\n          return _createSagaMonitor(b, a);\n        }\n      }\n    };\n  };\n};\n\nmodule.exports = index;","map":null,"metadata":{},"sourceType":"script"}